1 First-order logic (FOL) reading
∀x ∀y  (ExtensionWire(x)  ∧  splicedUsing(x,y)    →    CompatibleConnector(y))
∀x∀y(ExtensionWire(x)∧splicedUsing(x,y)→CompatibleConnector(y))

    If x is an Extension Wire and it is spliced using y, then y must be a Compatible Connector.

2 Description-logic axiom
ExtensionWire  ⊑  ∀ splicedUsing.CompatibleConnector
ExtensionWire⊑∀splicedUsing.CompatibleConnector

Prefix(:=<http://example.org/electrical#>)
Ontology(
  Declaration(Class(:ExtensionWire))
  Declaration(Class(:Connector))
  Declaration(Class(:CompatibleConnector))
  Declaration(ObjectProperty(:splicedUsing))

  # CompatibleConnector is a kind of Connector (optional but typical)
  SubClassOf(:CompatibleConnector :Connector)

  # Domain/Range declarations for clarity (optional)
  ObjectPropertyDomain(:splicedUsing :ExtensionWire)
  ObjectPropertyRange( :splicedUsing :Connector)

  # --- Requirement constraint ---
  SubClassOf(
    :ExtensionWire
    ObjectAllValuesFrom( :splicedUsing :CompatibleConnector )
  )
)

======================================



1 First-order logic (readable form)
∀p ∀x(WireSplicingAct(p)∧has_input(p,x)∧ExtensionWire(x)    ⇒    ∃y(CompatibleConnector(y)∧has_input(p,y)))
∀p∀x(WireSplicingAct(p)∧has_input(p,x)∧ExtensionWire(x)⇒∃y(CompatibleConnector(y)∧has_input(p,y)))

Any splicing act that takes an Extension Wire as input must also take a Compatible Connector as an input.
2 Description-logic axiom


Prefix(:=<http://example.org/electrical#>)
Prefix(bfo:=<http://purl.obolibrary.org/obo/BFO_>)
Prefix(cco:=<http://www.ontologyrepository.com/CommonCoreOntologies/>)
Prefix(ro:=<http://purl.obolibrary.org/obo/RO_>)
Ontology(
  #################################################################
  #  Classes
  #################################################################
  Declaration(Class(:ExtensionWire))
  Declaration(Class(:CompatibleConnector))
  Declaration(Class(:WireSplicingAct))      # domain-specific process
  # Optional: anchor in CCO process hierarchy
  SubClassOf(:WireSplicingAct cco:JoiningProcess)

  #################################################################
  #  Object Properties (all reused, no new ones defined)
  #################################################################
  #   ro:has_input        (RO_0002233)
  #   ro:participates_in  (RO_0000056)

  #################################################################
  #  Domain / Range hints (optional but helpful)
  #################################################################
  ObjectPropertyDomain(ro:has_input bfo:BFO_0000015)      # Processual Entity
  ObjectPropertyRange( ro:has_input bfo:BFO_0000040)      # Material Entity

  #################################################################
  #  Requirement constraint
  #################################################################
  SubClassOf(
      ObjectIntersectionOf(
        :WireSplicingAct
        ObjectSomeValuesFrom( ro:has_input :ExtensionWire )
      )
      ObjectSomeValuesFrom( ro:has_input :CompatibleConnector )
  )

  #################################################################
  #  Alternative (object-centred) constraint*
  #################################################################
  #  SubClassOf(
  #    :ExtensionWire
  #    ObjectAllValuesFrom(
  #       ro:participates_in
  #       ObjectIntersectionOf(
  #          :WireSplicingAct
  #          ObjectSomeValuesFrom( ro:has_input :CompatibleConnector )
  #       )
  #    )
  #  )
  #  *use this flavour if you prefer to put the restriction on
  #   the wire individuals rather than on the process class.
)

WireSplicingAct  ⊓  ∃ ⁣has_input.ExtensionWire⏟“splicing act with extension wire”    ⊑    ∃ ⁣has_input.CompatibleConnector
“splicing act with extension wire”
WireSplicingAct⊓∃has_input.ExtensionWire​​⊑∃has_input.CompatibleConnector
