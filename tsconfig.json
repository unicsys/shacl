import pandas as pd
import networkx as nx
from pyvis.network import Network
import json
import tempfile
import os

def modify_html(input_file, output_file, graph_title):
    with open(input_file, 'r', encoding='utf-8') as file:
        content = file.read()

    search_html = """
    <div style="position: absolute; top: 10px; left: 10px; z-index: 1000; display: flex; align-items: center;">
        <input type="text" id="search-input" class="form-control form-control-sm" placeholder="Search node..." style="margin-right: 5px; width: auto;" />
        <button onclick="searchNode()" class="btn btn-primary btn-sm">Search</button>
    </div>
    """
    
    title_html = f"""
    <div style="position: absolute; top: 10px; right: 10px; z-index: 1000; font-size: 18px; font-weight: bold;">
        {graph_title}
    </div>
    """

    search_script = """
    <script>
    function searchNode() {
        var input = document.getElementById('search-input').value.toLowerCase();
        var nodesFound = [];

        if (typeof network !== 'undefined' && network && network.body && network.body.data && network.body.data.nodes && typeof nodeColors !== 'undefined') {
            resetNodeColors(); 

            if (input.trim() !== "") { 
                network.body.data.nodes.forEach(function(node) {
                    if (node.id && typeof node.id === 'string' && node.id.toLowerCase().includes(input)) {
                        nodesFound.push(node.id);
                        network.body.data.nodes.update({id: node.id, color: "red"});
                    }
                });
            }

            if (nodesFound.length > 0) {
                network.selectNodes(nodesFound); 
                network.fit({nodes: nodesFound, animation: true}); 
            } else if (input.trim() !== "") {
                alert("Node(s) not found!");
            }
        } else {
            console.error("Network or nodeColors not initialized, or no nodes data.");
            if (input.trim() !== "") alert("Graph components not ready for search or no nodes to search.");
        }
    }

    function resetNodeColors() {
        if (typeof network !== 'undefined' && network && network.body && network.body.data && network.body.data.nodes && typeof nodeColors !== 'undefined') {
            network.body.data.nodes.forEach(function(node) {
                var originalColor = nodeColors[node.id];
                network.body.data.nodes.update({id: node.id, color: originalColor});
            });
        }
    }

    document.addEventListener('DOMContentLoaded', function() {
        var searchInput = document.getElementById('search-input');
        if (searchInput) {
            searchInput.addEventListener('keyup', function(event) {
                if (event.key === 'Enter') { 
                    event.preventDefault(); 
                    searchNode();
                }
            });
        }
    });
    </script>
    """

    click_handler_script = """
              network.on("click", function (params) {
                  resetNodeColors(); 

                  if (params.nodes.length > 0) { 
                      var clickedNodeId = params.nodes[0];
                      var nodesToHighlight = new Set();
                      nodesToHighlight.add(clickedNodeId); 

                      var immediateNeighbors = network.getConnectedNodes(clickedNodeId);
                      immediateNeighbors.forEach(function(neighborId) {
                          nodesToHighlight.add(neighborId); 

                          var neighborNodeData = nodes.get(neighborId); 
                          if (neighborNodeData && neighborNodeData.shape === 'box') {
                              var connectedToPredicate = network.getConnectedNodes(neighborId, 'from');
                              connectedToPredicate.forEach(function(subjNodeId) {
                                  if (subjNodeId !== clickedNodeId) { 
                                      nodesToHighlight.add(subjNodeId);
                                  }
                              });

                              var connectedFromPredicate = network.getConnectedNodes(neighborId, 'to');
                              connectedFromPredicate.forEach(function(objNodeId) {
                                  if (objNodeId !== clickedNodeId) { 
                                      nodesToHighlight.add(objNodeId);
                                  }
                              });
                          }
                      });

                      var idsToUpdate = Array.from(nodesToHighlight);
                      idsToUpdate.forEach(function(nodeId) {
                          network.body.data.nodes.update({id: nodeId, color: "red"});
                      });

                      network.selectNodes(idsToUpdate);
                      network.fit({nodes: idsToUpdate, animation: true});

                  } else { 
                      network.fit(); 
                  }
              });
    """

    content = content.replace('<body>', '<body>' + search_html + title_html)
    content = content.replace('</body>', search_script + '\n</body>')

    network_init_line = 'network = new vis.Network(container, data, options);'
    if network_init_line in content:
        content = content.replace(network_init_line, 
                                  network_init_line + '\n' + click_handler_script)
    else:
        print("Warning: Could not find network initialization line to inject click handler.")


    with open(output_file, 'w', encoding='utf-8') as file:
        file.write(content)

# Path to your CSV file
file_path = "bfo_file1.csv" 

if not os.path.exists(file_path):
    print(f"Warning: '{file_path}' not found. Creating a dummy file for testing.")
    with open(file_path, 'w') as f:
        f.write("Subject,Predicate,Object\n")
        f.write("ClassA,is_a,Entity\n")
        f.write("PropertyX,has data source,DataSource1\n")
        f.write("ClassA,has_property,PropertyX\n")
        f.write("DataSource1,has_type,Database\n")
        f.write("NodeX,predicate_to,NodeY\n") 
        f.write("NodeY,predicate_from,NodeZ\n")

G = nx.DiGraph()
df = pd.read_csv(file_path)

for index, row in df.iterrows():
    subject = str(row['Subject']) 
    predicate = str(row['Predicate'])
    object_ = str(row['Object'])
    
    G.add_node(subject) 
    G.add_node(object_)
    
    predicate_node_id = f"{subject}_{predicate}_{object_}"
    G.add_node(predicate_node_id, 
                 shape='box', 
                 color={'background':'white', 'border':'lightgray', 
                        'highlight': {'background':'white', 'border':'gray'}}, 
                 font={'size': 10, 'color': 'black'},
                 label=predicate,  
                 title=f"Predicate: {predicate}\n(Connects {subject} to {object_})")
    
    G.add_edge(subject, predicate_node_id)
    G.add_edge(predicate_node_id, object_)
    
    if predicate == "has data source":
        if G.has_node(object_):
            G.nodes[object_]['color'] = "yellow"

nt = Network(notebook=True, height="750px", width="100%", 
             bgcolor="#ffffff", font_color="black", directed=True, heading='',
             cdn_resources='remote') 

for node_id, node_data in G.nodes(data=True):
    explicit_label = node_data.get('label', node_id)
    other_node_attrs = {k: v for k, v in node_data.items() if k != 'label'}
    nt.add_node(node_id, label=explicit_label, **other_node_attrs)

for edge in G.edges():
    nt.add_edge(edge[0], edge[1])

# --- MODIFIED PHYSICS AND CONFIGURE OPTIONS ---
physics_config = {
    "enabled": True,
    "barnesHut": {
        "gravitationalConstant": -5000,  # Reduced repulsion (less negative)
        "centralGravity": 0.05,          # Slightly reduced central pull
        "springLength": 10,              # *** Significantly reduced spring length ***
        "springConstant": 0.04,          # Kept moderate, can be increased if edges feel too "loose"
        "damping": 0.30,                 # Adjusted damping slightly
        "avoidOverlap": 0.1              # Keep this moderate; increase if nodes overlap too much AFTER they are closer
    },
    "minVelocity": 0.5,                 # Keep low for stability
    "solver": "barnesHut",
    "stabilization": {
        "enabled": True,
        "iterations": 1000,
        "updateInterval": 25,
        "onlyDynamicEdges": False,
        "fit": True
    }
}

options = {
    "physics": physics_config,
    "configure": {
        "enabled": True,
        "filter": ["physics", "layout", "nodes", "edges", "interaction", "manipulation"],
        "showButton": True
    },
    # ... (rest of your options remain the same)
    "nodes": {
        "font": {"size": 12, "color": "black"},
        "shapeProperties": {"interpolation": False}
    },
    "edges": {
        "color": {"color": "#848484", "highlight": "#848484", "hover": "#848484", "inherit": False},
        "font": {"size": 10, "color": "grey", "face": "arial", "align": "horizontal"},
        "arrows": {"to": {"enabled": True, "scaleFactor": 0.5}},
        "smooth": {"enabled": True, "type": "dynamic"},
        "labelHighlightBold": True,
        "width": 0.5
    },
    "interaction": {
        "multiselect": True,
        "navigationButtons": True, 
        "keyboard": {"enabled": True, "speed": {"x": 10, "y": 10, "zoom": 0.03}, "bindToWindow": True},
        "hover": True,
        "tooltipDelay": 200,
        "dragNodes": True, 
        "dragView": True   
    },
    "manipulation": { 
        "enabled": False, 
    }
}
# --- END MODIFIED OPTIONS ---

nt.set_options(json.dumps(options))

temp_file_handle, temp_output_file_path = tempfile.mkstemp(suffix=".html", text=True)
os.close(temp_file_handle) 

try:
    nt.save_graph(temp_output_file_path)

    final_output_file = "graph_stk_refined.html"
    graph_title = "Basic Formal Ontology (BFO) Example"
    modify_html(temp_output_file_path, final_output_file, graph_title)
    print(f"Graph visualization saved to: {final_output_file}")

finally:
    try:
        os.remove(temp_output_file_path)
        print(f"Temporary file {temp_output_file_path} removed.")
    except OSError as e:
        print(f"Error removing temporary file {temp_output_file_path}: {e}")
