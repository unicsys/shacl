Data Population Plan (Straightforward Version)
1. Engine Instance

    Instance Name: eng:PW0E730123

    Source Table: EHMLINK_ENGINE

    Logic: Create one Engine node for each unique ENG_SN.

        Populate myont:hasSerialNumber from the ENG_SN column.

2. EngineComponent Instance

    Instance Name: comp:1A-BLADE_SN-BLADE-001

    Source Tables: ENG_INST_ITEM, ITEM_PN_LIST, ENG_PART_LOAD

    Logic: Create one EngineComponent node for each unique ENG_ITEM_PN + ENG_ITEM_SN combination.

        Populate myont:hasPartNumber from ENG_INST_ITEM.ENG_ITEM_PN.

        Populate myont:hasSerialNumber from ENG_INST_ITEM.ENG_ITEM_SN.

        Enrich with myont:hasDescription by looking up the PN in ITEM_PN_LIST.

3. InstalledState Instance (The Key to Simplicity)

    Instance Name: state:Blade_001_Installed_On_Eng_123_20230115

    Source Tables: ENG_INST_ITEM (for the start) and ON_EQUIP_ENG_WO/COMPLETE_TASK (to infer the end).

    Logic: This is the core of the ETL.

        For every row in ENG_INST_ITEM, create a new InstalledState instance. This row gives us the part, the engine, and the start time.

        The hasFirstInstant is directly populated from ENG_INST_ITEM.ITEM_INST_DTG. This is straightforward.

        The hasLastInstant is populated by finding the next major maintenance event for that same part that implies removal (like an action code for "Replaced"). This still requires some inference, but it's the most direct path available in your data. If no such event is found, the hasLastInstant remains null (meaning "currently installed").
